---
title: "Working With Custom Attributes and Summary Statistics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{attributes-and-summary-statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, include = FALSE}
library(EpiModel)
```

# Introduction

This vignette discusses some recent updates in `EpiModel` on working with attributes and summary statistics within the stochastic network model class. This material is oriented towards custom models with extension modules and functions. Further details are provided in the "New Network Models with EpiModel" section of [the EpiModel tutorials](https://www.epimodel.org/tut.html).

In network simulations with `netsim`, we store all data in the *Master List Object* (referred to as `dat`). In this vignette we will discuss with three types of data on `dat`:

-   *Current Nodal Attributes*
-   *Historical Nodal Attributes*
-   *Epidemic Trackers (Summary Model Statistics)*

# Current Nodal Attributes

*Attributes* are characteristics of the nodes (e.g., persons) in the model at the current time-step. By default, every node has a `unique_id` and an `active` *attribute* used to track each node, as well as three attributes used in the epidemic modules: `status` for disease status, `entrTime` for the time the node entered the population, and `exitTime` for the time the node left the population. Other attributes can be added of any name and value, like `age`, but must be stored as a scalar values.

We work with *attribute vectors* that are all of the same size of the number of nodes in the model. In the *attribute vectors*, a node is identified by its *Positional ID* or `posit_id` (i.e., the position in vector). The default *attribute* `unique_id` created for each node gives a unique identification number allowing us to refer to nodes no longer in the model. Deaths or other forms of exit from the network disrupt the positional ID but do not impact the unique ID.

## Working With Attributes

### Accessing

The `EpiModel::get_attr` function will extract the vector of a given *attribute*. In its simplest form, we can pull a complete *attribute vector* from `dat` like so:

```{r accessing-attr, eval = FALSE}
active <- EpiModel::get_attr(dat, "active")
```

The above call will pull from `dat` the `active` *attribute* for all nodes. `active` is a vector of size *current number of nodes*. With values being either 1 or 0 depending on whether a node is active or not.

Trying to extract an *attribute* that does not exist will cause `EpiModel::get_attr` to throw an error.

### Modifying Attributes

In custom extension modules, we usually want to modify some of the *attributes*. Below is a minimal module that increments the age of all the nodes by 1.

```{r modyfing-attr, eval = FALSE}
aging_module <- function(dat, at) {
  
  # Extract current attribute
  age <- EpiModel::get_attr(dat, "age")

  # Aging process
  new_age <- age + 1

  # Output updated attributes
  dat <- EpiModel::set_attr(dat, "age", new_age)

  return(dat)
}
```

Let's break down this very simple yet perfectly valid module.

1.  Pull the `age` *attribute vector* as we did in the previous section.
2.  Create a vector `new_age` incrementing all ages by one.
3.  Update the `dat` object with the `EpiModel::set_attr` function.
4.  Return the Updated `dat` object.

We can see that `EpiModel::set_attr` takes as arguments:

-   The `dat` object to update.
-   The name of the attribute vector of interest (here "age").
-   The new values for this vector (here `new_age`).

When using `EpiModel::set_attr`, there are several things to note:

-   The function does not modify the `dat` object, it merely returns a modified version of it to be assigned back to `dat`. (Nicely, this does not cause performance issues due to the way R handles shallow copies since version 3.1)
-   If `new_age` size is not equal to the number of nodes in the network, the function will throw an error.

### Advanced Options

The above example describes the recommended way to work with attribute:

1.  Extract the *attributes* into local vectors.
2.  Modify the local vectors with some dynamic process (like aging).
3.  Update the `dat` object with the revised local vectors.
4.  Return the `dat` object at the end of the function.

These functions have other arguments that are described in the documentation: see `help("net-accessor", package = "EpiModel")` for further details.

# Historical Attributes

We have seen how *Attributes* refers to the state of **every nodes** in the network **at the current time-step**. However, we sometimes want to keep track of what happened to some nodes at different time-steps. Because saving the full history of the *attributes* would consume too much RAM and is rarely necessary, EpiModel offers a way to record specific *attribute* for specific nodes at different time-steps.

The *Attribute History* is an efficient collection of recorded attributes at different time-steps. EpiModel comes with function to record these elements and to access them in a convenient manner once the simulation is over.

## Working with Attribute History

### Recording Attribute History

Here is a module that would record the viral load of infected nodes every 10 time-steps. We assume that this module is part of a model that defines 2 *attributes*:

-   `status` with possible values being "infected" or "susceptible"
-   `viral_load` as a number for the "infected" nodes and `NA` otherwise

```{r recordin_attr_hist, eval = FALSE}
viral_load_logger_module <- function(dat, at) {
  if (at %% 10 == 0) {
    # Attributes
    status <- EpiModel::get_attr(dat, "status")
    viral_load <- EpiModel::get_attr(dat, "viral_load")

    infected <- which(status == "infected")

    dat <- EpiModel::record_attr_history(
      dat, at,
      "viral_load",
      infected,
      viral_load[infected]
    )
  }

  # Output
  return(dat)
}
```

Let's break the code down:

1.  Check that the current time-step is a multiple of ten. If not got to 2.
2.  Pull the 2 *attribute vectors* of interest ("status" and "viral_load")
3.  Store in `infected` the `posit_id`s of the infected nodes
4.  Record the `viral_load` of `infected` nodes at time `at` under the label "viral_load"
5.  Return the `dat` object.

`EpiModel::record_attr_history` takes five arguments:

1.  the `dat` object
2.  the time-step to be associated with the record (here `at`, the current time-step)
3.  the label to be used for the attribute (here "viral_load")
4.  a vector of `posit_id`s referring to the nodes of interest (here `infected`)
5.  the values to be recorded (here `viral_load[infected]`)

We notice that `EpiModel::record_attr_history` requires a set of `posit_id`s. Internally the function will convert them to `unique_id`s so the *Attribute History* will not be affected by nodes entering or leaving the model over time.

When recording some *Attribute History*, we must make sure that we record as many values as there are `posit_id`s. Otherwise the function will throw an error. It however possible to use only one value even though we record a value for multiple nodes. This last situation actually uses less RAM as only one value is stored in the history for multiple nodes.

### Accessing the Attribute History

The *Attribute History* is meant to be accessed once the simulation is over. At that point we can use the `EpiModel::get_attr_history` function to pull it.

```{r access_attr_hist, eval = FALSE}
sim <- netsim(est, param, init, control)
attr_history <- EpiModel::get_attr_history(sim)
```

The `attr_history` object is a list of `data.frame`s. One for each measure that was recorded. Let's assume we were running two simulations, using the module defined above and another one recording when a node switched from infected to recovered and vice-versa.

```{r get_attr_ex, eval = FALSE}
get_attr_history(sim)

# $viral_load
#    sim step attribute    uids values
# 1  1   10   viral_load   1001   2000
# 2  1   10   viral_load   1002   1878
# 3  1   20   viral_load   1001   1500
# 4  1   20   viral_load   1002    300
# 5  2   10   viral_load    401   2500
# 6  2   10   viral_load    402   1378
# 7  2   20   viral_load    401   1200
# 8  2   20   viral_load    402    100
# ...
#
# $switch_status
#    sim step attribute      uids     values
# 1  1   22   switch_status  1001   infected
# 2  1   64   switch_status  1002   infected
# 3  1  110   switch_status  1001  recovered
# 4  1  220   switch_status  1002  recovered
# 5  2    7   switch_status   401   infected
# 6  2   15   switch_status   402   infected
# 7  2   20   switch_status   401  recovered
# 8  2  120   switch_status   402  recovered
# ...
```

We would get a named list of 2 `data.frame`:

-   "viral_load" with the `value` column being the viral loads
-   "switch_status" with the `value` column being whether the node became "infected" or "recovered" at the given time-step.

# Epidemic Trackers

The next type of data stored in `dat` is called *Epidemic Tracers*. It refers to information about the *population*, not the individual nodes. This information is created and stored for **each time step**.

Examples of such *Epidemic Trackers* is the `num` vector, storing the size of the population at each time-step.

## Working With Epidemic Trackers in Modules

Inside a module, *Epidemic Trackers* are accessed and modified with the functions `EpiModel::get_epi` and `EpiModel::set_epi`. Below is a new version of the `aging_module` defined above with the addition of trackers.

```{r epi-in-modules, eval = FALSE}
aging_track_module <- function(dat, at) {
  # Attributes
  age <- EpiModel::get_attr(dat, "age")

  # Logic
  new_age <- age + 1
  mean_age <- mean(new_age)
  prev_mean_age <- EpiModel::get_epi(dat, at - 1, "mean_age")
  age_change <- mean_age - prev_mean_age

  # Output
  dat <- EpiModel::set_attr(dat, "age", new_age)

  dat <- set_epi(dat, "mean_age", at, mean_age)
  dat <- set_epi(dat, "age_change", at, age_change)

  return(dat)
}
```

In this new module, in addition to incrementing the age by 1, we also record 2 values as *Epidemic Tracers*: the mean age of the population and the change in mean age compared to the previous step.

We get the mean age at the previous step using `EpiModel::get_epi` and set the second argument as `at - 1`. After all the calculations are done, we store `mean_age` and `age_change` in `dat` using `EpiModel::set_epi`.

-   Similarly to `EpiModel::set_attr`, `dat` is not modified directly and need to be assigned back to himself. Also, the value we store must be a scalar.
-   Trying to access an *Epidemic Trackers* that does not exist is an error, as is trying to access an invalid time-step.

## Accessing Epidemic Trackers After a Simulation

*Epidemic Trackers* are usually the main quantity of interest in a simulation. We access them simply by calling `as.data.frame` on a `netsim` object or by using the plot functions offered by EpiModel.

## Custom Epidemic Trackers

It can be useful to create small *Epidemic Trackers* outside of the modules and use them only when we need them. EpiModel contains an optional module called `EpiModel::trackers.net` allowing such functionality.

### Tracker functions

We call a *tracker function* a `function` that takes `dat` and `at` as arguments and outputs a scalar value. Every *tracker function* is run by the `trackers.net` module at each time step.

```{r tracker-example}
epi_s_num <- function(dat, at) {
  needed_attributes <- c("status")
  output <- with(get_attr_list(dat, needed_attributes), {
    out <- sum(status == "susceptible", na.rm = TRUE)

    out
  })

  return(output)
}
```

The `epi_s_num` function defined above is a *tracker function*. It calculates at each time-step the number of *susceptible* in the network.

The next example is a *tracker function* that calculates the proportion of the population that is infected at each time step. Let's look what each element does:

```{r tracker-commented}
epi_prop_infected <- function(dat, at) {
  # we need two attributes for our calculation: `status` and `active`
  needed_attributes <- c("status", "active")

  # we use `with` to simplify code
  output <- with(EpiModel::get_attr_list(dat, needed_attributes), {
    pop <- active == 1             # we only look at active nodes
    cond <- status == "infected"   # which are infected 

    # how many are `infected` among the `active`
    out <- sum(cond & pop, na.rm = TRUE) / sum(pop, na.rm = TRUE)

    out
  })

  return(output)
}
```

We recommend that you always make your *tracker functions* as follows:

1.  define a `needed_attributes` variable containing a vector of attribute names. (in this example: "status" and "active").
2.  use `with` and `EpiModel::get_attr_list(dat, needed_attributes)` to work in an environment with only the objects you need. This helps to understand what the tracker does and simplify the debugging process. We save the result of this call into `output`
3.  define `out` as the calculated outcome inside with, it MUST be a scalar. This is the last element evaluated by the `with` expression.
4.  `return(output)`, what was calculated inside the `with` construct.

### Using the `trackers.net` module

This functionality is part of an optional module provided by `EpiModel`, `trackers.net`. This module has to be enabled in `control.net`. And the *tracker functions* themselves must be declared as a named list in `control.net`: `tracker.list`. Let's make a simple SI module with some added trackers:

```{r tracker-list}
# Create the `tracker.list` list
some.trackers <- list(
  prop_infected = epi_prop_infected,
  s_num         = epi_s_num
)

control <- EpiModel::control.net(
  type = NULL, # must be NULL as we use a custom module
  nsims = 1,
  nsteps = 50,
  verbose = FALSE,
  infection.FUN = EpiModel::infection.net,
  trackers.FUN = EpiModel::trackers.net,
  tracker.list = some.trackers
)

param <- EpiModel::param.net(
  inf.prob = 0.3,
  act.rate = 0.1
)

nw <- network_initialize(n = 50)
nw <- set_vertex_attribute(nw, "race", rbinom(50, 1, 0.5))
est <- EpiModel::netest(
  nw,
  formation = ~edges,
  target.stats = 25,
  coef.diss = dissolution_coefs(~offset(edges), 10, 0),
  verbose = FALSE
)

init <- EpiModel::init.net(i.num = 10)
sim <- EpiModel::netsim(est, param, init, control)

d <- as.data.frame(sim)

knitr::kable(tail(d, n = 15))
```

Each function must be named in the `tracker.list` list. The name given there will be used to identify the *tracker function* in the `epi` list and will be the name of the corresponding column of the `data.frame` produced by `as.data.frame(sim)` where `sim` is a `netsim` object.

*Note*: in the `some.trackers` list, we put `epi_prop_infected` and `epi_s_num` without parentheses at the end. This is because we store the `function` and not the result of calling the function.

This is the minimal `control.net` to enable the module. Usually, a researcher will want to add it to a more complex model with several bespoke modules. See the "Advanced Extension Models" section in the [EpiModel tutorials](http://www.epimodel.org/tut.html).

**Important**: when enabling the `trackers.net` module, the researcher must pay particular attention to the order the modules are run. It is recommended to have the `trackers.net` module run last so the tracked values will reflect the state of the model at the end of the time step.

# Record Any Object (advanced / debugging)

When working with complex projects, we sometimes want to inspect the state of an object without stopping the simulation. The function `EpiModel::record_raw_object` allows the user to save any object during the simulation.

```{r record-raw, eval = FALSE}
introspect_module <- function(dat, at) {
  # Attributes
  age <- get_attr(dat, "age")
  
  if (mean(age, na.rm = TRUE) > 50) {
    obj <- data.frame(
        age = age,
        status = EpiModel::get_attr(dat, "status")
    )
    dat <- EpiModel::record_raw_object(dat, at, "old pop", obj)
  }

  return(dat)
}
```

In this module, we look at the age of the population and if the mean age is more than 50, we create a `data.frame` called `obj` containing the `age` and `status` *attribute vectors* and store it in a *Raw Record*.

This *Raw Record* can be accessed in the final `netsim` object for debugging purposes.

```{r record-raw-access, eval = FALSE}
sim <- netsim(est, param, init, control)
sim[["raw.records"]][[1]]
```
