---
title: "Random-parameterization-interface"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Random-parameterization-interface}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE}
library(EpiModel)
set.seed(1)
```

# Introduction

When working with network models, EpiModel offers an interface to include
random parameters. These might include a vector of potential parameter values
or a statistical distribution definition; in either case, one draw from the
generator would be completed per individual simulation.

# The model

First, we define a minimal dummy model. If this code does not make sense, please
check the [EpiModel tutorials](http://www.epimodel.org/tut.html).

```{r model}
nw <- network_initialize(n = 50)

est <- netest(
  nw, formation = ~edges,
  target.stats = c(25),
  coef.diss = dissolution_coefs(~offset(edges), 10, 0),
  verbose = FALSE
)


param <- param.net(
  inf.prob = 0.3,
  act.rate = 0.5,
  dummy.param = 4,
  dummy.strat.param = c(0, 1)
)

init <- init.net(i.num = 10)
control <- control.net(type = "SI", nsims = 1, nsteps = 5, verbose = FALSE)
mod <- netsim(est, param, init, control)
mod
```

In the parameter we set the value for `inf.prob` and `act.rate` as usual but
also define `dummy.param` and `dummy.strat.param`. These last 2 parameters are
not used by the model but will serve to illustrate random parameters and how to
handle stratified parameters. `dummy.strat.param` has two elements, this is
usually used to stratify a parameter by subpopulation.

The last line print a summary of the model and in it we can see the value of the
parameters under the "Fixed Parameters" section. Note the additional `groups`
parameter defined automatically by `EpiModel` as part of the "SI" model definition.

# Random parameters

Now we will want our parameters to take random values. For this, we use the
`random.params` argument to `param.net`. There are two ways of defining which
parameter to draw randomly and how to draw them.

## Generator functions

The first option is to define a generator function for each parameter we want to
randomize.

```{r generators}
my.randoms <- list(
  act.rate = param_random(c(0.25, 0.5, 0.75)),
  dummy.param = function() rbeta(1, 1, 2),
  dummy.strat.param = function() c(
    rnorm(1, 0.05, 0.01),
    rnorm(1, 0.15, 0.03)
  )
)

param <- param.net(
  inf.prob = 0.3,
  random.params = my.randoms
)

param
```

Here we kept the `inf.prob` parameter fixed at `0.3` and defined a list
`my.randoms` containing 3 elements:

- `act.rate` uses the `param_random` [function
  factory](https://adv-r.hadley.nz/function-factories.html) defined by EpiModel
  (see `?EpiModel::param_random`).
- `dummy.param` is a function with no argument that returns a random value from
  a beta distribution.
- `dummy.strat.param` is a function with no argument that returns 2 values
  sampled from normal distributions.

Each element is named after the parameter it will fill and MUST BE a function
taking no argument and outputting a vector of the right size for the parameter:
size 1 for `act.rate` and `dummy.param`; size 2 for `dummy.strat.param`.

```{r generators_run}
control <- control.net(type = "SI", nsims = 3, nsteps = 5, verbose = FALSE)
mod <- netsim(est, param, init, control)

mod
```

After running 3 simulations we can see that 2 parameters are still displayed under the
"Fixed Parameters" section: `inf.prob` and `groups`. The other ones are displayed
under the "Random Parameters". `act.rate` and `dummy.param` now have 3 values associated
with them, one per simulation. `dummy.strat.param` have `<list>` as value because
each simulation has a vector of size 2.

We can inspect the values with:

``` {r generators_inspect}
str(mod$param$random.params.values)
```

## Parameter set

The drawback of generator functions is that they cannot produce correlated
parameters. For instance, we will want `dummy.param` and `dummy.strat.param` to
be related to one another while allowing `act.rate` to take randomly one of the
3 values defined above.

We need to define a `data.frame` of the possible values:

```{r set_df}
n <- 5

related.param <- data.frame(
  dummy.param = rbeta(n, 1, 2)
)

related.param$dummy.strat.param_1 <- related.param$dummy.param + rnorm(n)
related.param$dummy.strat.param_2 <- related.param$dummy.param * 2 + rnorm(n)

related.param
```

We now have a `data.frame` with 25 rows and 3 columns. Each row contains a set
of parameters values that will be used together in a model. This way we keep the
relationship between each value.

The first column of the `data.frame` is named `dummy.param`, similar to the name
of the parameter. For `dummy.start.param` we need two columns as the parameter
contains two values. To achieve this, we name the 2 columns `dummy.start.param_1` and
`dummy.strat.param_2`. The value after the underscore informs `EpiModel` how it
should combine the values. This in turn means that the underscore symbol is not
allowed in the parameter names.

Then we set up the rest of the parameters. `related.param` is saved in the
`my.randoms` list under the special name `param_random_set`.

```{r set_param}
my.randoms <- list(
  act.rate = param_random(c(0.25, 0.5, 0.75)),
  param_random_set = related.param

)

param <- param.net(
  inf.prob = 0.3,
  random.params = my.randoms
)

param
```

Notice here that we combined a generator function for `act.rate` and a set of
correlated parameters with `param_random_set`.

```{r set_run}
control <- control.net(type = "SI", nsims = 3, nsteps = 5, verbose = FALSE)
mod <- netsim(est, param, init, control)

mod
```

The output is similar to what we saw with the generator functions.

**Where to get a Parameter set?**

In this example, we generated the parameter set ourselves. In real research, you
might want to use values coming from elsewhere. As long as you format them as
described above `EpiModel` will be able to use them.
