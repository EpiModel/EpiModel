---
title: "Attributes-History"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Attributes-History}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette discusses a mechanism usable inside `EpiModel` network models with
custom modules. More information about these in the "New Network Models with
EpiModel" section of [the EpiModel tutorials](http://www.epimodel.org/tut.html).

In a network simulation, we call "attribute" a value that refers to a node. By
default, every node has a `unique_id` and an `active` attribute but other
attributes can be added, like `status`, `age`, or anything as long as it is a
scalar value. These attributes are manipulated in the modules with the
`get_attr_list()`, `get_attr()`, and `set_attr` functions. These attributes
keep track of the state of each node at the current time step. However, they
have no memory. If a node goes from `status == "s"` to `status = "i"` at
time-step 10, in the future you lose the information about this transition.

# Attribute History

The function `record_attr_history()` therefore exists to save a "record" of the
state of particular nodes at a given time-step. It uses the following syntax:

```{r record_attr_history-ex, eval = FALSE}
# inside of a module
dat <- record_attr_history(dat, at, "my_attribute", some_indexes, values)
```

Similarly to `set_attr()`, `record_attr_history()` will mutate the `dat` object
and you will have to save the new version. The arguments are:

1. `dat` the Master list object of network models
2. `at` the timestep you want to associate the record to
3. `attribute` a character string naming the attribute to save
4. `posit_ids` a numeric vector of `posit_ids`, identifying the nodes to which
   the attribute applies
5. `values` the values to record

Once the simulations are over, the function `get_attr_history()` can be used on
the resulting `netsim` object to recover the history in `data.frame` form.


```{r record_attr_history-get, eval = FALSE}
sims <- netsim(netest, param, init, control)

get_attr_history(sims)

# $attra
#    sim step attribute uids values
# 1  1   10   attra     1001      a
# 2  1   10   attra     1002      b
# 3  1   11   attra     1003      a
# 4  1   11   attra     1004      b
# 5  2   10   attra     1001      a
# 6  2   10   attra     1002      b
# 7  2   10   attra     1003      a
# 8  2   11   attra     1004      b
# 9  2   11   attra     1005      a
#
# $attrb
#    sim step attribute uids values
# 1  1   10   attrb     1001      a
# 2  1   10   attrb     1002      b
# 3  1   11   attrb     1003      a
# 4  1   11   attrb     1004      b
# 5  2   10   attrb     1001      a
# 6  2   10   attrb     1002      b
# 7  2   10   attrb     1003      a
# 8  2   11   attrb     1004      b
# 9  2   11   attrb     1005      a
```

In the above mock example, the module saved 2 kinds of attributes in the
history: "attra" and "attrb". `get_attr_history()` returns a list of
`data.frame`, one for each of the attributes.

# Simple module example

Let's implement a simple module to showcase this functionality. This module
assumes that the infection being tracked is HIV. When the `status == "i"` a
node is infected and we keep track of his viral load with the `vl` attribute.
The module will record the viral load of all infected every 10 time steps.

```{r module-ex, eval = FALSE}
viral_load_logger <- function(dat, at) {
  if (at %% 10 == 0) {
    with(get_attr_list(dat, c("status", "vl")), {
      infected <- which(status == "i")
      dat <- record_attr_history(dat, at, "vl", infected, vl[infected])
    })
  }

  return(dat)
}
```

If we break down the code:

1. `if (at %% 10 == 0) {` checks that the timestep is divisible by 10
2. `with(get_attr_list(dat, c("status", "vl")), {` allows to access
   `status` and `vl` directly as variables
3. `infected <- which(status == "i")` find the `posit_ids` of each infected node
4. `dat <- record_attr_history(dat, at, "vl", infected, vl[infected])` stores
   the `vl` value for each of the infected nodes
5. `return(dat)` as a module must always `return` the master object, this line
   have to be outside of the `if` construct.

After the simulation is run, we can acces these values:

```{r module-get, eval = FALSE}
get_attr_history(sims)

# $vl
#    sim step attribute uids values
# 1  1   10   vl        1001   2000
# 2  1   10   vl        1002   1878
# 3  1   10   vl        1003   1500
# 4  1   10   vl        1004    300
# 5  1   20   vl        1001   2500
# 6  1   20   vl        1002   1378
# 7  1   20   vl        1003   1200
# 8  1   20   vl        1004    100
# ...
```
